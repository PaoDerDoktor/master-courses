# Complexité et calculabilité : 

## Introduction a la calculabilité et la complexité

On xonsidère un problème informatique que l'on peut représenter par une fonction f : A -> B où A et B sont des ensembles dénombrables.

____

Un algorithme est une suite finie et non ambigue d'instructions et d'opérations. 

____

Question principale de la calculabilité : Etant donné un problème et donc une fonction f, est ce que f est calculable (= il existe un algo qui permet de calculer f) ?

Nous considérons que nos machines on un espace mémoire et un temps infini. Si on peut le faire, c'est calculable. A l'inverse, si l'on ne peut pas le faire, c'est qu'il n'existe pas d'algorithme pour cette tache.

En complexité, on essaye de donner un critere pour déterminer les performances d'un algorithme en temps et en mémoire. 

*j'arrive pas a noter mes mains sont geles et il parle trop vite...*

Problème calculable = on peut trouver un algo solution

L'argument de cardinalité :

[https://youtu.be/N_cDA6t_______](Deux (deux ?) minutes pour l'hôtel de Hillbert)

On prouvera formellement tous ces résultats dans le TD1. 

En résumé : 

On dit que deux ensembles infini ou fini sont de meme cardinalité s'il existe une bijection entre les deux.
Il existe plusieurs cardinalités infinies différentes :
    - N, Z, Q, \sigma * (ensembles des mots finis sur un alphabet fini). Ensemble des algos ont tous la meme cardinalités, ils sont denombrables
    - R, [0, 1]
    - Grace a l'argument de la diagonale de Cantor, on peut prouver que |N| < |R| : il y a beaucoup plus de problemes d'algorithme et donc il existe des fonction non calculables.

Ce simple argument prouve que la très grande majorité des fonctions sont non calculables. Mais ça ne nous dit pas qu'il y a des fonction intéressantes qui sont non calculables. A ce stade ou pourrait meme penser qu'aucune fonction pourrait décrire formellement n'est non calculable. ___

Machine de turing

____

L'idée est d'avoir une mémoire infinie représentée par un ruban. On a une tete de lecture et l'on ne peut que lire la case, modifier le contenue et se déplacer à gauche ou a droite. Elle est défini par un automate.

cf : schéma automate

Machine de turing = 7 uplet

- Q ensembles fini : les états
- \gamma (r) ensemble finif : alphabet de ruban
- \sigma (E) c \gamma (r) alphabet d'entrée
- reprendre le CM ce sera plus facile

La fonction de transition n'est pas nécessairement définit, dans la cas om l'on tombe sur un tel évènement, l'algorithmme s'arrete tout simplement.

Initialement le mot d'entée est écrit sur le ruban et toutes es autres cellulles contiennent le symbole blanc B. Etat initial = Q_0.

Acceptation : si au cours des transitions la machine entre dans l'etat final Q_f et s'arrete.
Rejet : Si au cours des transitions al machine s'arrete dans un etat non final (si pas de mouvement ensuite)
____

Soucis : On est sencé avoir des machines de turing pur tout les types et non pas pour des boolean uniquement.

On peut facilement definir des varaiations de cette machine qui permet de calculer d'autre types de fonciton. On peut aussi trouver une fonction de décision equivalente d'un point de vue calculatoire. ____

## Calculer, décider et langages

Un langage est décidable, s'il est reconnu par une machine de turing qui s'arrete sur toutes les entrees
Un langage est semi-deciddable s'il est reconnu par une machine de turing
Un langage est co-semi-decidable si son complement est semi-decidable

un langage est decidable ssi il est semi decidable et co semi decidable (preuve au TD3)

## Sources

- CM de Florian Bridoux 10/01/2022